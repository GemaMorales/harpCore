% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/neighbourhoods.R
\name{nbhd_smooth}
\alias{nbhd_smooth}
\alias{cumsum_2d}
\alias{nbhd_smooth_cumsum}
\title{Smooth a 2d field based an a neighbourhood radius}
\usage{
nbhd_smooth(
  x,
  radius,
  threshold = NA,
  comparator = c("ge", "gt", "le", "lt", "between", "outside"),
  include_low = TRUE,
  include_high = TRUE,
  boundary = c("zero_pad", "missing")
)

cumsum_2d(
  x,
  threshold = NA,
  comparator = c("ge", "gt", "le", "lt", "between", "outside"),
  include_low = TRUE,
  include_high = TRUE
)

nbhd_smooth_cumsum(x, radius, boundary = c("zero_pad", "missing"))
}
\arguments{
\item{x}{A 2d array, geofield or geolist.}

\item{radius}{The radius of the neighbourhood in pixels.}

\item{threshold}{A threshold for computing binary probabilities. If
\code{comparator = "between"}, it must be a two element vector. Set to NA
to use the raw data.}

\item{comparator}{How to compare \code{x} with the threshold to compute
binary probabilities. Can be \code{"ge"}, \code{"gt"}, \code{"le"}, or
\code{"lt"} for >=, >, <= and < respectively. Can also be
\code{"between"} or \code{"outside"}, in which case the binary probability
of being between or outside of the two values given in \code{threshold} is
computed.}

\item{include_low}{Logical. Whether to include to the lower of the two
thresholds in the comparison when \code{comparator = "between"} or
\code{comparator = "outside"}.}

\item{include_high}{Logical. Whether to include to the higher of the two
thresholds in the comparison when \code{comparator = "between"} or
\code{comparator = "outside"}.}

\item{boundary}{How to treat the boundaries. Current options are
\code{"zero_pad"} and \code{"missing"}. See Details for more information
on these options.}
}
\value{
A smoothed 2d field. In the case of geofields and geolists, the
attributes are retained.
}
\description{
\code{nbhd_smooth} takes a 2d field, and for each pixel in that field a
square neighbourhood is constructed with a specified radius - that is the
number of pixels to the left/right and above/below the pixel at the
neighbourhood centre. For each pixel, the mean value of the pixels in the
neighbourhood is returned resulting in a smoothed field on the same grid as
the original field.
}
\details{
For pixels that are closer to the edge of the input field than the radius
there are two options. The default is to zero pad the field outwards with
pixels outside of the original field set to zero. If
\code{boundary = "missing"} the pixels closer to the edge than the radius
will be set to missing.

The neighbourhood means are computed by first calculating the cumulative sum
of the array from the top left to the bottom right and then computing the
total for each neighbourhood by subtraction. This means that the algorithm
is equally efficient regardless of the neighbourhood size. It is possible
to compute each stage at a time with fist \code{cumsum_2d} and then
\code{nbhd_smooth_cumsum}.

If a threshold is given, the binary probability of the input field compared
with the threshold is computed at each pixel before applying the function.
By default the comparison is \code{x >= threshold}, but other comparisons
can be chosen using the \code{comparator} argument.
}
\examples{
# Create a 2d array
z <- array(dim = c(100, 100))
for (i in 1:100) {
  for (j in 1:100) {
    z[i, j] <- sin(i / 10) + sin(j / 10)
 }
}

image(z, zlim = range(z), col = heat.colors(255))
# With zero-padding the input array
image(nbhd_smooth(z, 5), zlim = range(z), col = heat.colors(255))
image(nbhd_smooth(z, 10), zlim = range(z), col = heat.colors(255))
image(nbhd_smooth(z, 20), zlim = range(z), col = heat.colors(255))

# Without zero padding
image(nbhd_smooth(z, 5, boundary = "missing"), zlim = range(z), col = heat.colors(255))
image(nbhd_smooth(z, 10, boundary = "missing"), zlim = range(z), col = heat.colors(255))

# Add a threshold
image(nbhd_smooth(z, 10, 0.5), zlim = c(0, 1), col = heat.colors(255))
image(nbhd_smooth(z, 10, 0.5, "lt"), zlim = c(0, 1), col = heat.colors(255))
image(nbhd_smooth(z, 10, c(-0.5, 0.5), "between"), zlim = c(0, 1), col = heat.colors(255))
image(nbhd_smooth(z, 10, c(-0.5, 0.5), "outside"), zlim = c(0, 1), col = heat.colors(255))
}
