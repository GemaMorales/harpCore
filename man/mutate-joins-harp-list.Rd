% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dplyr_methods.R
\name{mutate-joins-harp-list}
\alias{mutate-joins-harp-list}
\alias{inner_join.harp_list}
\alias{left_join.harp_list}
\alias{right_join.harp_list}
\alias{full_join.harp_list}
\title{Mutating joins for harp_lists}
\usage{
\method{inner_join}{harp_list}(x, y, by = NULL, ...)

\method{left_join}{harp_list}(x, y, by = NULL, ...)

\method{right_join}{harp_list}(x, y, by = NULL, ...)

\method{full_join}{harp_list}(x, y, by = NULL, ...)
}
\arguments{
\item{x, y}{A pair of data frames, data frame extensions (e.g. a tibble), or
lazy data frames (e.g. from dbplyr or dtplyr). See \emph{Methods}, below, for
more details.}

\item{by}{A join specification created with \code{\link[dplyr:join_by]{join_by()}}, or a character
vector of variables to join by.

If \code{NULL}, the default, \verb{*_join()} will perform a natural join, using all
variables in common across \code{x} and \code{y}. A message lists the variables so
that you can check they're correct; suppress the message by supplying \code{by}
explicitly.

To join on different variables between \code{x} and \code{y}, use a \code{\link[dplyr:join_by]{join_by()}}
specification. For example, \code{join_by(a == b)} will match \code{x$a} to \code{y$b}.

To join by multiple variables, use a \code{\link[dplyr:join_by]{join_by()}} specification with
multiple expressions. For example, \code{join_by(a == b, c == d)} will match
\code{x$a} to \code{y$b} and \code{x$c} to \code{y$d}. If the column names are the same between
\code{x} and \code{y}, you can shorten this by listing only the variable names, like
\code{join_by(a, c)}.

\code{\link[dplyr:join_by]{join_by()}} can also be used to perform inequality, rolling, and overlap
joins. See the documentation at \link[dplyr:join_by]{?join_by} for details on
these types of joins.

For simple equality joins, you can alternatively specify a character vector
of variable names to join by. For example, \code{by = c("a", "b")} joins \code{x$a}
to \code{y$a} and \code{x$b} to \code{y$b}. If variable names differ between \code{x} and \code{y},
use a named character vector like \code{by = c("x_a" = "y_a", "x_b" = "y_b")}.

To perform a cross-join, generating all combinations of \code{x} and \code{y}, see
\code{\link[dplyr:cross_join]{cross_join()}}.}

\item{...}{
  Arguments passed on to \code{\link[dplyr:mutate-joins]{dplyr::inner_join}}, \code{\link[dplyr:mutate-joins]{dplyr::left_join}}, \code{\link[dplyr:mutate-joins]{dplyr::right_join}}, \code{\link[dplyr:mutate-joins]{dplyr::full_join}}
  \describe{
    \item{\code{suffix}}{If there are non-joined duplicate variables in \code{x} and
\code{y}, these suffixes will be added to the output to disambiguate them.
Should be a character vector of length 2.}
    \item{\code{keep}}{Should the join keys from both \code{x} and \code{y} be preserved in the
output?
\itemize{
\item If \code{NULL}, the default, joins on equality retain only the keys from \code{x},
while joins on inequality retain the keys from both inputs.
\item If \code{TRUE}, all keys from both inputs are retained.
\item If \code{FALSE}, only keys from \code{x} are retained. For right and full joins,
the data in key columns corresponding to rows that only exist in \code{y} are
merged into the key columns from \code{x}. Can't be used when joining on
inequality conditions.
}}
  }}
}
\value{
A \code{harp_list} with the same names as \code{x}.
}
\description{
These are the \code{harp_list} methods for join functions, for example
\code{\link[dplyr]{inner_join}} from the \code{dplyr} package. In the case
of x being a \code{harp_list}, \code{y} can either be a data frame or
another \code{harp_list} that is the same length of \code{x}. If
\code{y} is a data frame, an attempt will be made to join \code{y} to
each data frame in the \code{harp_list}, \code{x}. If \code{y} is
a \code{harp_list}, data frames in corresponding elements of \code{x} and
\code{y} will be joined. Note that this is done on the basis of location
in the list and names are not taken into account. Names in the output are
always taken from the names of \code{x}.
}
